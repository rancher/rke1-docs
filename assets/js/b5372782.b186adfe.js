"use strict";(self.webpackChunkrke_docs=self.webpackChunkrke_docs||[]).push([[9381],{8363:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var r=a(5893),t=a(1151);const i={title:"Configuring the Upgrade Strategy"},o=void 0,s={id:"upgrades/configuring-strategy/configuring-strategy",title:"Configuring the Upgrade Strategy",description:"In this section, you'll learn how to configure the maximum number of unavailable controlplane and worker nodes, how to drain nodes before upgrading them, and how to configure the replicas for addons such as Ingress.",source:"@site/docs/upgrades/configuring-strategy/configuring-strategy.md",sourceDirName:"upgrades/configuring-strategy",slug:"/upgrades/configuring-strategy/",permalink:"/upgrades/configuring-strategy/",draft:!1,unlisted:!1,editUrl:"https://github.com/rancher/rke1-docs/edit/main/docs/upgrades/configuring-strategy/configuring-strategy.md",tags:[],version:"current",lastUpdatedAt:1704844723,formattedLastUpdatedAt:"Jan 9, 2024",frontMatter:{title:"Configuring the Upgrade Strategy"},sidebar:"mySidebar",previous:{title:"Maintaining Availability for Applications During Upgrades",permalink:"/upgrades/maintaining-availability/"},next:{title:"Kubeconfig File",permalink:"/kubeconfig/"}},l={},d=[{value:"Maximum Unavailable Nodes",id:"maximum-unavailable-nodes",level:3},{value:"Draining Nodes",id:"draining-nodes",level:3},{value:"Replicas for Ingress and Networking Addons",id:"replicas-for-ingress-and-networking-addons",level:3},{value:"Replicas for DNS and Monitoring Addons",id:"replicas-for-dns-and-monitoring-addons",level:3},{value:"Example cluster.yml",id:"example-clusteryml",level:3}];function c(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"In this section, you'll learn how to configure the maximum number of unavailable controlplane and worker nodes, how to drain nodes before upgrading them, and how to configure the replicas for addons such as Ingress."}),"\n",(0,r.jsx)(n.h3,{id:"maximum-unavailable-nodes",children:"Maximum Unavailable Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["The maximum number of unavailable controlplane and worker nodes can be configured in the ",(0,r.jsx)(n.code,{children:"cluster.yml"})," before upgrading the cluster:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"max_unavailable_controlplane:"})," The maximum number of controlplane nodes that can fail without causing the cluster upgrade to fail. By default, ",(0,r.jsx)(n.code,{children:"max_unavailable_controlplane"})," is defined as one node."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"max_unavailable_worker:"})," The maximum number of worker nodes that can fail without causing the cluster upgrade to fail. By default, ",(0,r.jsx)(n.code,{children:"max_unavailable_worker"})," is defined as 10 percent of all worker nodes.*"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"/*  This number can be configured as a percentage or as an integer. When defined as a percentage, the batch size is rounded down to the nearest node, with a minimum of one node per batch."}),"\n",(0,r.jsx)(n.p,{children:"An example configuration of the cluster upgrade strategy is shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"upgrade_strategy:\n  max_unavailable_worker: 10%\n  max_unavailable_controlplane: 1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"draining-nodes",children:"Draining Nodes"}),"\n",(0,r.jsx)(n.p,{children:"By default, nodes are cordoned first before upgrading. Each node should always be cordoned before starting its upgrade so that new pods will not be scheduled to it, and traffic will not reach the node. In addition to cordoning each node, RKE can also be configured to drain each node before starting its upgrade. Draining a node will evict all the pods running on the computing resource."}),"\n",(0,r.jsxs)(n.p,{children:["For information on draining and how to safely drain a node, refer to the ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/",children:"Kubernetes documentation."})]}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"drain"})," directive is set to ",(0,r.jsx)(n.code,{children:"true"})," in the ",(0,r.jsx)(n.code,{children:"cluster.yml"}),", worker nodes will be drained before they are upgraded. The default value is false:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"upgrade_strategy:\n  max_unavailable_worker: 10%\n  max_unavailable_controlplane: 1\n  drain: false\n  node_drain_input:\n    force: false\n    ignore_daemonsets: true\n    delete_local_data: false\n    grace_period: -1 // grace period specified for each pod spec will be used\n    timeout: 60\n"})}),"\n",(0,r.jsx)(n.h3,{id:"replicas-for-ingress-and-networking-addons",children:"Replicas for Ingress and Networking Addons"}),"\n",(0,r.jsxs)(n.p,{children:["The Ingress and network addons are launched as Kubernetes ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",children:"daemonsets."})," If no value is given for the ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy",children:"update strategy,"})," Kubernetes sets the update strategy to ",(0,r.jsx)(n.code,{children:"rollingUpdate"})," by default, with ",(0,r.jsx)(n.code,{children:"maxUnavailable"})," set to 1."]}),"\n",(0,r.jsx)(n.p,{children:"An example configuration of the Ingress and network addons is shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"ingress:\n  provider: nginx\n  update_strategy:\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 5\nnetwork:\n  plugin: canal\n  update_strategy:\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 6\n"})}),"\n",(0,r.jsx)(n.h3,{id:"replicas-for-dns-and-monitoring-addons",children:"Replicas for DNS and Monitoring Addons"}),"\n",(0,r.jsxs)(n.p,{children:["The DNS and monitoring addons are launched as Kubernetes ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/",children:"deployments."})," These addons include ",(0,r.jsx)(n.code,{children:"coredns"}),", ",(0,r.jsx)(n.code,{children:"kubedns"}),", and ",(0,r.jsx)(n.code,{children:"metrics-server"}),", the monitoring deployment."]}),"\n",(0,r.jsxs)(n.p,{children:["If no value is configured for their ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy",children:"update strategy"})," in the ",(0,r.jsx)(n.code,{children:"cluster.yml"}),", Kubernetes sets the update strategy to ",(0,r.jsx)(n.code,{children:"rollingUpdate"})," by default, with ",(0,r.jsx)(n.code,{children:"maxUnavailable"})," set to 25% and ",(0,r.jsx)(n.code,{children:"maxSurge"})," set to 25%."]}),"\n",(0,r.jsxs)(n.p,{children:["The DNS addons use ",(0,r.jsx)(n.code,{children:"cluster-proportional-autoscaler"}),", which is an ",(0,r.jsx)(n.a,{href:"https://github.com/kubernetes-incubator/cluster-proportional-autoscaler",children:"open-source container image"})," that watches over the number of schedulable nodes and cores of the cluster and resizes the number of replicas for the required resource. This functionality is useful for applications that need to be autoscaled with the number of nodes in the cluster. For the DNS addon, the fields needed for the ",(0,r.jsx)(n.code,{children:"cluster-proportional-autoscaler"})," are made configurable."]}),"\n",(0,r.jsx)(n.p,{children:"The following table shows the default values for these fields:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Field Name"}),(0,r.jsx)(n.th,{children:"Default Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"coresPerReplica"}),(0,r.jsx)(n.td,{children:"128"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"nodesPerReplica"}),(0,r.jsx)(n.td,{children:"4"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"min"}),(0,r.jsx)(n.td,{children:"1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"preventSinglePointFailure"}),(0,r.jsx)(n.td,{children:"true"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"cluster-proportional-autoscaler"})," uses this formula to calculate the number of replicas:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plain",children:"replicas = max( ceil( cores * 1/coresPerReplica ) , ceil( nodes * 1/nodesPerReplica ) )\nreplicas = min(replicas, max)\nreplicas = max(replicas, min)\n"})}),"\n",(0,r.jsx)(n.p,{children:"An example configuration of the DNS and monitoring addons is shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"dns:\n  provider: coredns\n  update_strategy:\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 20%\n      maxSurge: 15%\n  linear_autoscaler_params:\n    cores_per_replica: 0.34\n    nodes_per_replica: 4\n    prevent_single_point_failure: true\n    min: 2\n    max: 3\nmonitoring:\n  provider: metrics-server\n  update_strategy:\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 8\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-clusteryml",children:"Example cluster.yml"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# If you intened to deploy Kubernetes in an air-gapped environment,\n# please consult the documentation on how to configure custom RKE images.\nnodes:\n# At least three etcd nodes, two controlplane nodes, and two worker nodes,\n# nodes skipped for brevity\nupgrade_strategy:\n  max_unavailable_worker: 10%\n  max_unavailable_controlplane: 1\n  drain: false\n  node_drain_input:\n    force: false\n    ignore_daemonsets: true\n    delete_local_data: false\n    grace_period: -1 // grace period specified for each pod spec will be used\n    timeout: 60\ningress:\n  provider: nginx\n  update_strategy: # Available in v2.4\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 5\nnetwork:\n  plugin: canal\n  update_strategy: # Available in v2.4\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 6\ndns:\n  provider: coredns\n  update_strategy: # Available in v2.4\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 20%\n      maxSurge: 15%\n  linear_autoscaler_params:\n    cores_per_replica: 0.34\n    nodes_per_replica: 4\n    prevent_single_point_failure: true\n    min: 2\n    max: 3\nmonitoring:\n  provider: metrics-server\n  update_strategy: # Available in v2.4\n    strategy: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 8\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1151:(e,n,a)=>{a.d(n,{Z:()=>s,a:()=>o});var r=a(7294);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);